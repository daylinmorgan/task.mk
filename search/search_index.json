{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"task.mk  <p>   the task runner for GNU Make you've been missing   </p> <p></p> <p>GNU make is an excellent build tool and the task runner we love to hate, but can't escape. So let's improve the UX to make it the best task runner it can be.</p> <p><code>Task.mk</code>, is a standalone <code>Makefile</code> you can deploy alongside your own to add some QOL improvements for your users and fellow maintainers.</p> <p>Current Features:</p> <ul> <li>ANSI escape code support (including NO_COLOR)</li> <li>formatted help output</li> <li>custom print function</li> <li>confirmation prompt</li> </ul> <p>Depends on <code>GNU Make</code>, obviously and <code>Python &gt;=3.7</code>, and <code>bash</code> (or <code>zsh</code>).</p> <p>Wait python?!?!, I'm not <code>pip</code> installing some package just to parse my makefile. I agree, all you need is one file <code>.task.mk</code>. You can automagically include it with just two additional lines to your <code>Makefile</code> (and probably one to your <code>.gitignore</code>) and your good to go.</p>"},{"location":"#setup","title":"Setup","text":"<p>You can include this as an optional dependency on your project by adding the below lines to the end of your <code>Makefile</code>. If someone tries to invoke <code>make help</code> it will download <code>.task.mk</code> for them.</p> <pre><code>-include .task.mk\n$(if $(filter help,$(MAKECMDGOALS)),$(if $(wildcard .task.mk),,.task.mk: ; curl -fsSL https://raw.githubusercontent.com/daylinmorgan/task.mk/v23.1.1/task.mk -o .task.mk))\n</code></pre> <p>You might also consider making it a consistently downloaded dependency if you plan to use any of it's advanced feature set, by dropping the <code>$(MAKECMDGOALS)</code> check.</p> <pre><code>-include .task.mk\n$(if $(wildcard .task.mk),,.task.mk: ; curl -fsSL https://raw.githubusercontent.com/daylinmorgan/task.mk/v23.1.1/task.mk -o .task.mk)\n</code></pre> <p>Alternatively, you can use the builtin rule <code>_update-task.mk</code> to update to the latest development version.</p> <p>See Usage to get started running all your tasks. See Examples for more use cases.</p>"},{"location":"#zsh-completions-for-gnu-make","title":"Zsh Completions for GNU Make","text":"<p>If you use <code>GNU Make</code> with zsh you may want to add the following line to your rc file to allow <code>make</code> to handle the autocomplete.</p> <pre><code>zstyle ':completion::complete:make:*:targets' call-command true\n</code></pre>"},{"location":"#why-make","title":"Why Make?","text":"<p>There are lot of <code>GNU Make</code> alternatives but none have near the same level of ubiquity. This project attaches to <code>make</code> some of the native features of <code>just</code>, a command runner.</p> <p>Just is a great task runner, but it suffers two problems, users probably don't have it installed already, and there is no way to define file specific recipes. Most of my <code>Makefile</code>'s are comprised primarily of handy <code>.PHONY</code> recipes, but I always end up with a few file specific recipes.</p> <p>Another interesting project I've evaluated for these purposes is <code>go-task/task</code>. <code>Task</code> has many of the features of <code>GNU Make</code> and some novel features of it's own. But like <code>just</code> it's a tool people don't usually already have and it's configured using a <code>yaml</code> file. <code>Yaml</code> files can be finicky to work with and and it uses a golang based shell runtime, not your native shell, which might lead to unexpected behavior.</p>"},{"location":"#simpler-alternative","title":"Simpler Alternative","text":"<p>But I just want a basic help output, surely I don't need python for this... you would be right. <code>Task.mk</code> replaces my old <code>make help</code> recipe boilerplate which may better serve you (so long as you have <code>sed</code>/<code>awk</code>).</p> <pre><code>## h, help | show this help\n.PHONY: help h\nhelp h: Makefile\n@awk -v fill=$(shell sed -n 's/^## \\(.*\\) | .*/\\1/p' $&lt; | wc -L)\\\n'match($$0,/^## (.*) \\|/,name) &amp;&amp; match($$0,/\\| (.*)$$/,help)\\\n        {printf \"\\033[1;93m%*s\\033[0m | \\033[30m%s\\033[0m\\n\",\\\n        fill,name[1],help[1];} match($$0,/^### (.*)/,str) \\\n        {printf \"%*s   \\033[30m%s\\033[0m\\n\",fill,\" \",str[1];}' $&lt;\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p><code>Task.mk</code> will add access to a recipe <code>help</code> (also aliased to <code>h</code>). In order to use <code>make help</code> to you will need to add some custom comments to your <code>Makefile</code>.</p> <p>Deliberately, I don't get names from recipes themselves. This not only greatly simplifies the parsing but add's some opportunity to customize the output. Such as to document wildcard or redundant recipes.</p> <p>You can place these anywhere, but I recommend adding these notes directly above their relevant recipes. The format is <code>## &lt;recipe&gt; | &lt;msg&gt;</code></p> <pre><code>## build | build the project\n.PHONY: build\nbuild:\n...\n</code></pre> <p>Now when you invoke <code>make help</code> it will parse these and generate your help output.</p> <p>In addition to a generic help output you can expose some configuration settings with <code>make vars</code>. To do so define the variables you'd like to print with <code>PRINT_VARS := VAR1 VAR2 VAR3</code>.</p> <p>In addition to the <code>help</code> and <code>vars</code> recipes you can use a custom make function to format your text for fancier output. For this there are two options depending on your needs <code>tprint</code> or <code>tprint-sh</code>. (<code>tprint-sh</code> is for use within a multiline sub-shell that has already been silenced, see the version-check rule of this project's <code>Makefile</code> for an example.)</p> <p>To use <code>tprint</code> you call it with the builtin <code>make</code> call function. It accepts only one argument: an unquoted f-string literal. All strings passed to <code>tprint</code> have access to an object <code>ansi</code> or <code>a</code> for simplicity. This stores ANSI escape codes which can be used to style your text.</p> <p><pre><code>## build | compile the source\n.PHONY: build\nbuild:\n$(call tprint,{a.cyan}Build Starting{a.end})\n...\n  $(call tprint,{a.green}Build Finished{a.end})\n</code></pre> See this projects <code>make info</code> for more examples of <code>tprint</code>.</p> <p>To see the available colors and formatting(bold,italic,etc.) use the hidden recipe <code>make _print-ansi</code>.</p> <p>Note: Any help commands starting with an underscore will be ignored. To view hidden <code>tasks</code> (or recipes in GNU Make land) you can use <code>make _help</code>.</p> <p>In addition, you can use custom colors using the builtin <code>ansi.custom</code> or (<code>a.custom</code>) method. It has two optional arguments <code>fg</code> and <code>bg</code>. Which can be used to specify either an 8-bit color from the 256 colors. Or a tuple/list to define an RBG 24-bit color, for instance <code>a.custom(fg=(5,10,255))</code>. See this project's <code>make info</code> for an example.</p>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>You can quickly customize some of the default behavior of <code>task.mk</code> by overriding the below variables prior to the <code>-include .task.mk</code>. These can also be included in a seperate file <code>.task.cfg.mk</code>.</p> <pre><code># ---- [config] ---- #\nHEADER_STYLE ?= b_cyan\nACCENT_STYLE ?= b_yellow\nPARAMS_STYLE ?= $(ACCENT_STYLE)\nGOAL_STYLE ?= $(ACCENT_STYLE)\nMSG_STYLE ?= faint\nDIVIDER_STYLE ?= default\nDIVIDER ?= \u2500\nHELP_SEP ?= \u2502\n# python f-string literals\nEPILOG ?=\nUSAGE ?={ansi.$(HEADER_STYLE)}usage{ansi.end}:\\n  make &lt;recipe&gt;\\n\nINHERIT_SHELL ?=\n</code></pre> <p>To use a custom color for one of the predefined configuration variables specify only the custom method.</p> <pre><code>HEADER_STYLE = custom(fg=171,bg=227)\n</code></pre> <p>NOTE: <code>HELP_SEP</code> does not change the argument definitions syntax only the format of <code>make help</code>.</p>"},{"location":"usage/#advanced-usage-embedded-python-scripts","title":"Advanced Usage: Embedded Python Scripts","text":"<p>You can take advantage of the builtin python script runner and write multi-line python scripts of your own. This is a simple example but a few lines of python in your <code>Makefile</code> may be easier than balancing sub-shells and strung together awk commands.</p> <p>When <code>make</code> expands the function it will take the parameters passed to <code>py</code> and expand them. <code>$(1)</code> is the variable name and <code>$(2)</code> in this case is the implicit pattern from the rule. Pay attention to quotes. If you need to debug your python script, use <code>TASKMK_DEBUG=1</code> when you run <code>make</code> and it will first print the script that will be piped to <code>python</code>.</p> <pre><code>define list_files_py\nfrom pathlib import Path\nprint(\"files in $(2)\")\nprint([f.name for f in (Path(\"$(2)\").iterdir())])\nendef\n## list-% | use pathlib.Path to list files\nlist-%:\n$(call py,list_files_py,$*)\n</code></pre> <p>For what it's worth there is also a predefined function for <code>bash</code> (named <code>tbash</code>) as well should you need to accomplish something similar of more easily embedding your bash script rather than having to escape every line with a backslash.</p> <pre><code>define bash_script\nfiglet task.mk 2&gt;/dev/null || echo 'no figlet :('\necho \"This is from bash\"\ncat /etc/hostname\nprintf \"%s\\n\" \"$(2)\"\nendef\n.PHONY: test-bash\ntest-bash:\n$(call tbash,bash_script,test bash multiline)\n</code></pre>"},{"location":"examples/","title":"Examples","text":"Confirm <p>Perform a basic confirmation test with the user and exit with error code 1 if input is N/n.</p> Embedded Scripts <p>Use the builtin functions to write multi-line python/bash scripts directly in your <code>Makefile</code></p> Recipe Help <p>Display the target, docstring and recipe for a given target then exit.</p>"},{"location":"examples/check/","title":"Check","text":"check.mk<pre><code>## check | get user confirmation or exit\n.PHONY: check\ncheck:\n$(call tconfirm,Would you like to proceed?)\n@echo \"you said yes!\"\ndefine USAGE\n{a.$(HEADER_STYLE)}usage:{a.end}\n    make &lt;recipe&gt;\n\ninteractivity w/ task.mk\\n\nendef\n.DEFAULT_GOAL = help\ninclude $(shell git rev-parse --show-toplevel)/task.mk\n</code></pre>"},{"location":"examples/embedded/","title":"Embedded","text":"embedded.mk<pre><code>### examples of task.mk features | args: --divider --align center --msg-style b_red\ndefine list_files_py\nfrom pathlib import Path\nprint(\"files in $(2)\")\nprint([f.name for f in (Path(\"$(2)\").iterdir())])\nendef\n## list-% | use pathlib.Path to list files\n### name the directory in rule (make list-src) | args: --align sep\nlist-%:\n$(call py,list_files_py,$*)\n# dollar signs will always be a problem\ndefine bash_script\necho \"Is the process running bash? We can check with ps\"\nps -o args= -p $$$$ | grep -E -m 1 -o '\\w{0,5}sh'\nif [ -x \"$(command -v figlet)\" ]; then\necho 'no figlet :('\nelse\necho \"What text to figlet? \"\nread name\n    figlet $$name\nfi\necho \"the argument below as given in the makefile itself\"\necho \"it's expanded before the script is passed to bash\"\nprintf \"%s\\n\" \"$(2)\"\nendef\n## embedded-bash | bash script with pipes and make input\n.PHONY: embedded-bash\nembedded-bash:\n$(call tbash,bash_script,bash multiline is probably working)\ndefine USAGE\n{a.$(HEADER_STYLE)}usage:{a.end}\n    make &lt;recipe&gt;\n\nexamples of embedded scripts in `{a.magenta}Makefile{a.end}`\nendef\n.DEFAULT_GOAL = help\ninclude $(shell git rev-parse --show-toplevel)/task.mk\n</code></pre>"},{"location":"examples/recipe-help/","title":"Recipe Help","text":"recipe-help.mk<pre><code>## deps-only | a task/target with dependencies\n.PHONY: deps-only\ndeps-only: foo\n## foo | a dummy rule that depends on the local files\n.PHONY: foo\nfoo: $(wildcard *)\n@echo 'this is a dummy rule'\n# bar but no docstring\n.PHONY: bar\nbar:\n@echo 'some rule with no help string'\ndefine USAGE\n{a.header}usage:{a.end}\n    make &lt;recipe&gt;\n    make help &lt;recipe&gt;\n\nendef\n.DEFAULT_GOAL = help\ninclude $(shell git rev-parse --show-toplevel)/task.mk\n</code></pre>"}]}